<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BUAA-OS-Sigaction-Challenge</title>
    <url>/2024/06/30/BUAA-OS-Challenge-Sigaction/</url>
    <content><![CDATA[<h1>Challenge-Sigaction实验报告</h1>
<h2 id="一、任务背景——sigaction简介">一、任务背景——sigaction简介</h2>
<p><code>sigaction</code>是Unix与类Unix操作系统中进程间或者内核与进程间的一种<strong>异步通信</strong>，用来提醒一个进程某一信号已经发生。</p>
<hr>
<p>当一个信号被发送给一个进程时, 内核会中断进程的正常控制流，转而<strong>执行与该信号相关的用户态处理函数</strong>进行处理，在执行该处理函数前，会将该信号所设置的信号屏蔽集加入到进程的信号屏蔽集中，在执行完该用户态处理函数后，又会将恢复原来的信号屏蔽集;本次实验只需实现<code>[1,32]</code>普通信号，无需考虑<code>[33,64]</code>的实时信号。</p>
<h2 id="二、实现思路">二、实现思路</h2>
<h3 id="1-概述">1. 概述</h3>
<p>综合本次实验的指导书、讨论区助教的总结和大佬们的指点、往届学长学姐宝贵的博客，我对此次任务形成的大致思路以及编码流程如下：</p>
<ul>
<li>在进程控制块中添加用于存储该进程已注册的信号、当前待处理的信号、当前屏蔽的信号集、用于实现信号重入的信号屏蔽栈、信号异常处理函数的入口的数据结构。</li>
<li>在用户态实现一系列用于处理信号集的函数，其中涉及到进程控制块数据改变的需要配合系统调用来实现，这也是此次实验初次上手比较困难的一部分。</li>
<li>仿照<code>tlb_mod</code>异常处理实现信号异常处理，完成上述系统调用的实现之后，对用户态内核态的关系和转换已经比较熟悉了，而且有参照，这部分不太难。</li>
<li>具体实现<code>do_signal</code>函数，难点在于实现指导书所要求的信号处理优先级机制，这里我反复修改了多次信号相关的数据结构（这说明一定要提前做好规划啊！不然牵一发而动全身，debug太难了）终于成功实现所需功能。</li>
<li>调整指导书要求的6个信号的发送方式和默认处理方式，这里只需要在内核中找到会导致相关信号出现的地方，添加系统调用发送信号即可。</li>
</ul>
<h3 id="2-信号相关的数据结构">2. 信号相关的数据结构</h3>
<p>在<code>include/signal.h</code>中添加指导书给出的两个结构体定义，以及6个需要实现的信号量、<code>__how</code>的宏定义，这里不再赘述和展示。</p>
<p>在<code>include/env.h</code>的<code>Env</code>结构体中添加信号处理相关的属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// challenge-sigaction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 已经注册的信号</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sigaction_list</span>[33];</span></span><br><span class="line"><span class="comment">// 当前待处理的信号</span></span><br><span class="line"><span class="type">int</span> env_todo_sig[<span class="number">33</span>];</span><br><span class="line"><span class="comment">// 当前的信号掩码（屏蔽集）</span></span><br><span class="line"><span class="type">sigset_t</span> env_sa_mask;</span><br><span class="line"><span class="comment">// 信号重入栈</span></span><br><span class="line"><span class="type">sigset_t</span> env_old_mask[<span class="number">33</span>];</span><br><span class="line"><span class="type">int</span> env_old_mask_top;</span><br><span class="line"><span class="comment">// 信号处理函数入口</span></span><br><span class="line">u_int env_sig_entry;</span><br></pre></td></tr></table></figure>
<p>当然，也不能忘了在创建<code>env</code>的时候初始化这些新增的属性。</p>
<h3 id="3-信号处理函数的实现">3. 信号处理函数的实现</h3>
<h4 id="不需要使用系统调用，仅在用户态执行的">不需要使用系统调用，仅在用户态执行的</h4>
<p>由于评测不允许新建<code>.c</code>文件，而原本<code>libos.c</code>文件中只有<code>exit</code>函数，所以我将这部分信号处理函数都放在该文件中。这部分函数实现较简单，需要注意信号编号是<code>[1,32]</code>，而<code>uint32_t</code>应该是<code>0-31</code>位；以及根据讨论区同学的指点，要注意判断传入的指针是否为空。其余不再赘述。</p>
<p><code>include/libos.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空，全置0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *__set)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (__set == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    __set-&gt;sig = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填满，全置1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *__set)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (__set == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    __set-&gt;sig = <span class="number">0</span>;</span><br><span class="line">    __set-&gt;sig = ~(__set-&gt;sig);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个信号，将某位 置1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">int</span> __signo)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (__set == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (__signo &gt; <span class="number">32</span> || __signo &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __set-&gt;sig |= (<span class="number">1</span> &lt;&lt; (__signo - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除一个信号，将某位 置0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">int</span> __signo)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (__set == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (__signo &gt; <span class="number">32</span> || __signo &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __set-&gt;sig &amp;= ~(<span class="number">1</span> &lt;&lt; (__signo - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查信号集是否包含__signo信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *__set, <span class="type">int</span> __signo)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (__set == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (__signo &gt; <span class="number">32</span> || __signo &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (((__set-&gt;sig &gt;&gt; (__signo<span class="number">-1</span>)) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查信号集是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigisemptyset</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *__set)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (__set == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> (__set-&gt;sig == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个信号集的交集</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigandset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">const</span> <span class="type">sigset_t</span> *__left, <span class="type">const</span> <span class="type">sigset_t</span> *__right)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (__set == <span class="literal">NULL</span> || __left == <span class="literal">NULL</span> || __right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    __set-&gt;sig = __left-&gt;sig &amp; __right-&gt;sig;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个信号集的并集</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigorset</span><span class="params">(<span class="type">sigset_t</span> *__set, <span class="type">const</span> <span class="type">sigset_t</span> *__left, <span class="type">const</span> <span class="type">sigset_t</span> *__right)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (__set == <span class="literal">NULL</span> || __left == <span class="literal">NULL</span> || __right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    __set-&gt;sig = __left-&gt;sig | __right-&gt;sig;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="需要使用系统调用的">需要使用系统调用的</h4>
<p>即需要对内核态的数据结构进行修改的。有<code>sigaction</code>，<code>kill</code>，<code>sigprocmask</code>，<code>sigpending</code>4个，用户态的很好写，判断一下边界条件，直接调用<code>sycall_*</code>方法即可。</p>
<p><code>user/lib/libos.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 信号注册函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *newact, <span class="keyword">struct</span> sigaction *oldact)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (signum &gt; <span class="number">32</span> || signum &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (syscall_get_sig_act(<span class="number">0</span>, signum, oldact) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册信号处理函数入口</span></span><br><span class="line">    <span class="keyword">if</span> (env_set_sig_entry() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> syscall_set_sig_act(<span class="number">0</span>, signum, newact);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号发送函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(u_int envid, <span class="type">int</span> sig)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall_kill(envid, sig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号屏蔽函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> __how, <span class="type">const</span> <span class="type">sigset_t</span> *__set, <span class="type">sigset_t</span> *__oset)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__set == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (__how &lt; <span class="number">1</span> || __how &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> syscall_set_sig_set(<span class="number">0</span>, __how, __set, __oset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前进程被阻塞且未处理的信号集</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *__set)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__set == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> syscall_get_sig_pending(<span class="number">0</span>, __set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内核态具体的实现。</p>
<p><code>kern/syscall_all.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送信号我的处理是将对应进程块的待处理信号集对应位置置1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_kill</span><span class="params">(u_int envid, <span class="type">int</span> sig)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (sig &gt; <span class="number">32</span> || sig &lt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	env-&gt;env_todo_sig[sig] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给当前进程注册一个信号，设置sigaction结构体的两个属性即可，注意类型转换</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_set_sig_act</span><span class="params">(u_int envid, <span class="type">int</span> signum, <span class="keyword">struct</span> sigaction *act)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (act) &#123;</span><br><span class="line">		env-&gt;sigaction_list[signum].sa_handler = (<span class="type">void</span> *)act-&gt;sa_handler;</span><br><span class="line">		env-&gt;sigaction_list[signum].sa_mask = act-&gt;sa_mask;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面函数的逆操作，获取当前进程指定信号的sigaction结构体的两个属性</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_get_sig_act</span><span class="params">(u_int envid, <span class="type">int</span> signum, <span class="keyword">struct</span> sigaction *oldact)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (oldact) &#123;</span><br><span class="line">		oldact-&gt;sa_handler = (<span class="type">void</span> *)env-&gt;sigaction_list[signum].sa_handler;</span><br><span class="line">		[env-&gt;env_sa_mask_top];</span><br><span class="line">		oldact-&gt;sa_mask = env-&gt;sigaction_list[signum].sa_mask;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置当前进程当前的信号屏蔽集</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_set_sig_set</span><span class="params">(u_int envid, <span class="type">int</span> how, <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">0</span>));</span><br><span class="line">	<span class="comment">// 保存原来的信号掩码</span></span><br><span class="line">	<span class="keyword">if</span> (oldset) &#123;</span><br><span class="line">		oldset-&gt;sig = env-&gt;env_sa_mask.sig;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">set</span>) &#123;</span><br><span class="line">		<span class="comment">// env-&gt;env_sa_mask_top++;</span></span><br><span class="line">		<span class="keyword">if</span> (how == SIG_BLOCK) &#123;</span><br><span class="line">			<span class="comment">// 将set指定的信号添加到当前进程的信号掩码中</span></span><br><span class="line">			env-&gt;env_sa_mask.sig |= <span class="built_in">set</span>-&gt;sig;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (how == SIG_UNBLOCK) &#123;</span><br><span class="line">			<span class="comment">// 将set指定的信号从当前进程的信号掩码中删除</span></span><br><span class="line">			env-&gt;env_sa_mask.sig &amp;= ~(<span class="built_in">set</span>-&gt;sig);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 将当前进程的信号掩码设置为set指定的信号</span></span><br><span class="line">			env-&gt;env_sa_mask.sig = <span class="built_in">set</span>-&gt;sig;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取当前进程待处理且未被阻塞的信号，即待处理集对应位为1且屏蔽集对应位不为1，要注意特判不能被阻塞的SIGKILL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_get_sig_pending</span><span class="params">(u_int envid, <span class="type">sigset_t</span> *<span class="built_in">set</span>)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (envid2env(envid, &amp;env, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((env-&gt;env_sa_mask.sig &gt;&gt; (i<span class="number">-1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 被阻塞就跳过，但是SIGKILL不可被阻塞</span></span><br><span class="line">			<span class="keyword">if</span> (i != SIGKILL) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (env-&gt;env_todo_sig[i]) &#123;</span><br><span class="line">			<span class="built_in">set</span>-&gt;sig &amp;= (<span class="number">1</span> &lt;&lt; (i<span class="number">-1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现完整系统调用的其他必要操作不再赘述。</p>
<h3 id="4-信号异常处理的实现">4. 信号异常处理的实现</h3>
<p>这部分是此次操作的核心，要实现从用户态到内核态再到用户态的转变。总的来说就是</p>
<p>用户态发生某事件导致给某进程发送信号-&gt;某进程在某次从内核态跳回用户态的过程中进入信号异常处理，根据优先级选择一个待处理的信号进行处理-&gt;对应进程跳到用户态的信号处理函数进行处理……</p>
<p>这个过程不断循环，就是完整的信号处理流程：<code>正常控制流——发——选——处理——正常控制流</code></p>
<h4 id="用户态的信号处理函数">用户态的信号处理函数</h4>
<p>负责接受内核态传来的参数，若有定义好的<code>sa_handler</code>则执行，否则按默认处理。除了默认处理是结束进程的（根据指导书要求，用用户态的<code>exit()</code>函数结束进程），最后都要进行系统调用恢复现场，也就是回到之前的内核态。</p>
<p><code>user/lib/fork.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 信号异常处理函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) sig_entry(<span class="keyword">struct</span> Trapframe *tf, <span class="type">void</span> (*sa_handler)(<span class="type">int</span>), <span class="type">int</span> signum, <span class="type">int</span> envid) &#123;</span><br><span class="line">	<span class="keyword">if</span> (sa_handler != <span class="number">0</span> &amp;&amp; signum != SIGKILL) &#123;</span><br><span class="line">		sa_handler(signum);	<span class="comment">//调用信号对应的处理函数</span></span><br><span class="line">		<span class="comment">// 恢复现场</span></span><br><span class="line">		<span class="type">int</span> r = syscall_set_sig_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">		user_panic(<span class="string">&quot;sig_entry syscall_set_trapframe return %d&quot;</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 没定义处理函数，进行默认处理</span></span><br><span class="line">	<span class="keyword">if</span> (signum == SIGINT || signum == SIGILL || signum == SIGSEGV || signum == SIGKILL) &#123;</span><br><span class="line">		<span class="comment">// 默认停止进程</span></span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">		user_panic(<span class="string">&quot;sig_entry syscall_env_destory return&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 默认忽略</span></span><br><span class="line">		<span class="comment">// 直接恢复现场</span></span><br><span class="line">		<span class="type">int</span> r = syscall_set_sig_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">		user_panic(<span class="string">&quot;sig_entry syscall_set_trapframe return %d&quot;</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="恢复现场的系统调用">恢复现场的系统调用</h4>
<p>可以参考已有的<code>sys_set_trapframe</code>函数实现<code>sys_set_sig_trapframe</code>，实际上实现逻辑是一摸一样的，但我选择在这个用户态到内核态的过渡函数（实际上现在已经回到内核态了）里维护进程的信号掩码栈——运行到这里说明已经处理完了一个信号，要将该信号的自我屏蔽取消，为了便于实现使用栈来操作，只要在这里将栈顶指针回退一格就行。</p>
<p><code>kern/syscall_all.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_sig_trapframe</span><span class="params">(u_int envid, <span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va_range((u_long)tf, <span class="keyword">sizeof</span> *tf)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">	<span class="comment">// 维护信号掩码栈</span></span><br><span class="line">	curenv-&gt;env_old_mask_top -= <span class="number">1</span>;</span><br><span class="line">	curenv-&gt;env_sa_mask.sig = curenv-&gt;env_old_mask[curenv-&gt;env_old_mask_top].sig;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (env == curenv) &#123;</span><br><span class="line">		*((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>) = *tf;</span><br><span class="line">		<span class="keyword">return</span> tf-&gt;regs[<span class="number">2</span>];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		env-&gt;env_tf = *tf;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内核态的信号处理函数">内核态的信号处理函数</h4>
<p>这应该是实现该任务最核心的函数了，该函数位于内核态，要在这里选出要处理的信号，将相关参数传给用户态的信号处理函数，我将几乎所有与信号优先级、信号重入、<code>SIGKILL</code>的特殊处理相关的操作都放在了这里。由于对信号的操作必然涉及对内核数据的修改，因此放在内核态实现是非常理所当然的。</p>
<p>总体思路是：先从待处理信号集中找一个信号出来处理。讨论区讨论比较多的关于信号优先级和信号被打断等问题。其实所谓被打断和优先级是不相干的，但本质上又是同一个问题，因为该信号处理机制遵循的原则就是收到信号-&gt;到内核态处理-&gt;根据编号小的优先级高，被屏蔽的不能选两条规则选一个信号出来处理，又因为规定每个信号在被处理的过程中会屏蔽自己，所以实际上被打断的时候是无关优先级的，换句话说：只要在处理一个信号的过程中，收到另一个非同类信号，是一定会被打断的。但为什么说本质是同一个问题呢？因为代码实现的逻辑没有区别，只要遵循两条原则+一个SIGKILL特例来处理就可以了。</p>
<p><code>kern/tlbex.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_signal</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前待处理信号集为空，就直接返回</span></span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (curenv-&gt;env_todo_sig[i] == <span class="number">1</span>) &#123;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找一个信号出来处理</span></span><br><span class="line">	<span class="type">int</span> sig_do_now = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 对SIGKILL特殊对待，只要它在待处理信号集里，就必须去执行</span></span><br><span class="line">	<span class="keyword">if</span> (curenv-&gt;env_todo_sig[SIGKILL]) &#123;</span><br><span class="line">		sig_do_now = SIGKILL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((curenv-&gt;env_sa_mask.sig &gt;&gt; (i<span class="number">-1</span>)) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">// 被阻塞就跳过</span></span><br><span class="line">				<span class="keyword">continue</span>;	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (curenv-&gt;env_todo_sig[i]) &#123;</span><br><span class="line">				sig_do_now = i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 待处理信号集中的信号恰巧全被屏蔽了，没法处理，直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (sig_do_now == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找完了，接下来要到用户态的分发函数</span></span><br><span class="line">	<span class="comment">// 先把当前的屏蔽集存到栈里，然后更新当前的屏蔽集，把当前要去处理的信号的屏蔽集及其自身放到当前的屏蔽集里</span></span><br><span class="line">	<span class="keyword">if</span> (sig_do_now != SIGKILL) &#123;</span><br><span class="line"></span><br><span class="line">		curenv-&gt;env_old_mask[curenv-&gt;env_old_mask_top].sig = curenv-&gt;env_sa_mask.sig;</span><br><span class="line">		curenv-&gt;env_old_mask_top += <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		curenv-&gt;env_sa_mask.sig |= curenv-&gt;sigaction_list[sig_do_now].sa_mask.sig;</span><br><span class="line">		curenv-&gt;env_sa_mask.sig |= (<span class="number">1</span> &lt;&lt; (sig_do_now - <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新完屏蔽集，可以跳转到用户态的分发函数了</span></span><br><span class="line">    <span class="comment">// 即将进入用户态处理函数，可以认为该信号已经被处理了，因此将其从待处理信号集中删去</span></span><br><span class="line">    <span class="comment">// 实际上这样不会影响信号的重入机制，如果该信号在处理过程中被打断，那么其被打断时的现场是会被打断他的那个信号保存的，可以保证继续执行</span></span><br><span class="line">	curenv-&gt;env_todo_sig[sig_do_now] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存现场，传参，跳转到用户态处理函数</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">	&#125;</span><br><span class="line">	tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">	*(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (curenv-&gt;env_sig_entry) &#123;</span><br><span class="line">		tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];</span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);</span><br><span class="line">		tf-&gt;regs[<span class="number">5</span>] = (<span class="type">unsigned</span> <span class="type">int</span>)</span><br><span class="line">		(curenv-&gt;sigaction_list[sig_do_now].sa_handler);</span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">5</span>]);</span><br><span class="line">		tf-&gt;regs[<span class="number">6</span>] = sig_do_now;</span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">6</span>]);</span><br><span class="line">		tf-&gt;regs[<span class="number">7</span>] = curenv-&gt;env_id;</span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">7</span>]);</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">		tf-&gt;cp0_epc = curenv-&gt;env_sig_entry;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		panic(<span class="string">&quot;sig but no user handler registered&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用户态和内核态的桥梁">用户态和内核态的桥梁</h4>
<p>要实现进程每次从内核态回到用户态时，进入信号处理函数<code>do_signal</code>，需要在<code>ret_from_exception</code>中添加跳转指令。</p>
<p><code>kern/genex.S</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">FEXPORT(ret_from_exception)</span><br><span class="line">	move	a0, sp</span><br><span class="line">    addiu   sp, sp, -8</span><br><span class="line">    jal     do_signal</span><br><span class="line">    nop</span><br><span class="line">    addiu   sp, sp, 8</span><br><span class="line"></span><br><span class="line">    RESTORE_ALL</span><br><span class="line">    eret</span><br></pre></td></tr></table></figure>
<h4 id="给用户态设置异常处理函数的入口">给用户态设置异常处理函数的入口</h4>
<p>仿照<code>tlb_mod</code>的处理实现一个入口地址<code>sig_entry</code>，在<code>sigaction</code>函数中调用，但是可能存在没有注册信号就发送该信号的情况。经过讨论区同学的提醒，可以在<code>libos.c</code>中的<code>libmain</code>函数中的<code>main</code>之前，调用一次异常处理函数入口注册函数，这样就保证了被取出来的进程控制块是注册过<code>sig_entry</code>的。</p>
<p><code>kern/syscall_all.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_sig_entry</span><span class="params">(u_int envid, u_int func)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">	env-&gt;env_sig_entry = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子进程继承父进程信号量的实现">子进程继承父进程信号量的实现</h4>
<p>子进程需要继承的是：父进程已经注册的信号、信号处理入口、信号屏蔽集，其余内容初始化。在内核中创建子进程的地方直接赋值即可。</p>
<p><code>kern/syscall_all.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//challenge-sigaction</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">		e-&gt;sigaction_list[i] = curenv-&gt;sigaction_list[i];</span><br><span class="line"></span><br><span class="line">		e-&gt;env_old_mask[i].sig = <span class="number">0</span>;</span><br><span class="line">		e-&gt;env_todo_sig[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_sa_mask = curenv-&gt;env_sa_mask;</span><br><span class="line">	e-&gt;env_sig_entry = curenv-&gt;env_sig_entry;</span><br><span class="line"></span><br><span class="line">	e-&gt;env_old_mask_top = <span class="number">0</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内核态信号发送的实现">内核态信号发送的实现</h4>
<p>根据指导书要求，<code>SIGCHLD</code>、<code>SIGILL</code>、<code>SIGSYS</code>、<code>SIGSEGV</code>信号是由内核发出的，这就要求我们对内核做出相应的修改。</p>
<h5 id="SIGSEGV"><code>SIGSEGV</code></h5>
<p>指导书中已明确说明，需要在访问到低于<code>0x003fe000</code>的地址时取消原有的<code>panic</code>，改为发送信号。</p>
<p><code>kern/tlbex.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">passive_alloc</span><span class="params">(u_int va, Pde *pgdir, u_int asid)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (va &lt; UTEMP) &#123;</span><br><span class="line">		sys_kill(<span class="number">0</span>, SIGSEGV);</span><br><span class="line">		<span class="comment">// panic(&quot;address too low&quot;);</span></span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h5 id="SIGCHLD"><code>SIGCHLD</code></h5>
<p>根据指导书描述，该信号是子进程终止信号，我的理解是子进程终止时要给父进程发送该信号，所以我找到内核态中销毁进程处，在真正销毁前给父进程发送该信号。</p>
<p><code>kern/syscall_all.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_env_destroy</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	try(envid2env(envid, &amp;e, <span class="number">1</span>));</span><br><span class="line">	sys_kill(e-&gt;env_parent_id, SIGCHLD);</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;[%08x] destroying %08x\n&quot;</span>, curenv-&gt;env_id, e-&gt;env_id);</span><br><span class="line">	env_destroy(e);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SIGILL"><code>SIGILL</code></h5>
<p>根据指导书描述，该信号表示执行了非法指令，内核中原有的处理应该在<code>do_reserved</code>函数中，我取消了该函数原有的当前异常栈打印和<code>panic</code>，改为发送信号。</p>
<p><code>kern/traps.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_reserved</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    sys_kill(<span class="number">0</span>, SIGILL);</span><br><span class="line">	<span class="comment">// print_tf(tf);</span></span><br><span class="line">	<span class="comment">// panic(&quot;Unknown ExcCode %2d&quot;, (tf-&gt;cp0_cause &gt;&gt; 2) &amp; 0x1f);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SIGSYS"><code>SIGSYS</code></h5>
<p>根据指导书定义，该信号表示系统调用号未定义，系统调用是<code>syscall</code>，显然相关的处理应该在<code>do_syscall</code>函数中，在这里我将<code>cp0_epc</code>加4以保证返回后跳过该未定义的系统调用指令，之后再发送信号。</p>
<p><code>kern/syscall_all.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">	<span class="type">int</span> (*func)(u_int, u_int, u_int, u_int, u_int);</span><br><span class="line">	<span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">if</span> (sysno &lt; <span class="number">0</span> || sysno &gt;= MAX_SYSNO) &#123;</span><br><span class="line">		tf-&gt;regs[<span class="number">2</span>] = -E_NO_SYS;</span><br><span class="line">		tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line">		sys_kill(<span class="number">0</span>, SIGSYS);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<h2 id="三、实验难点">三、实验难点</h2>
<p>我认为本次实验最难的是理解用户态和内核态的关系，以及是如何进行切换的。该任务每一部分的处理都会涉及用户态和内核态的关联、切换问题；其次是信号优先级和重入机制的实现，尤其是重入机制，涉及到掩码栈的维护，用户态内核态的不断切换……我对于优先级和重入机制的理解与具体实现已经在实现思路中体现。</p>
<h2 id="四、心得体会">四、心得体会</h2>
<p>完成该挑战性任务之后，我大大加深了对于操作系统内核态与用户态的理解程度，也更能理解为什么<em>原仓周老师</em>说操作系统可以理解成一个异常处理流，在此次实现的信号机制中，操作系统内核完成的任务是接收信号，挑选信号，把相应的信号发送给对应的进程去处理，而这一切在用户态都是不可见的，用户态只需要发送信号，然后就可以等着信号被处理了。</p>
<h2 id="五、碎碎念以及鸣谢">五、碎碎念以及鸣谢</h2>
<p>这次挑战性任务完成的十分艰难，心路历程及过程如下：</p>
<ul>
<li>五月底挑战性任务发布，走马观花地浏览了一遍，找了找学长学姐的<code>github</code>和博客，没有太多想法，遂搁置。</li>
<li>六月一直到端午假期，都没在关注挑战性任务，只是偶尔看看讨论区大伙热火朝天的讨论，尤其是<code>Sigaction</code>这题，心里有点痒痒，我又对<code>Shell</code>的题比较感兴趣，遂于端午节第一天开始写，结果以失败告终，心态一整个大崩啊。</li>
<li>端午节第二天收拾心情，果断止损，抓紧开始复习期末考试，这在后来看来是十分明智的选择。因为讨论区仍在不断迭代，到后期有了超级多有用的资源，大佬已经把石头摆好了，后来人只要摸着石头过河就行。而我在这个时间及时的复习了数据库和人工智能，进入考期后也能借着考试之间的空隙全力进攻挑战性任务。</li>
<li>考期第一周周二晚上，刚考完软工的我发现了<a href="https://yanna-zy.github.io/2023/06/18/BUAA-OS-challenge/">张杨学姐的博客</a>，对去年的挑战性任务有非常详细的讲解，与今年的题面进行对比后，发现总体框架变化不是很大，于是我果断换题。</li>
<li>借助学姐的博客，又翻着自己以前<code>lab</code>的代码，我彻底搞懂了<strong>系统调用</strong>和<strong>异常处理</strong>的流程以及<code>MOS</code>中代码的体现，也对挑战性任务的整体流程有了大致把握。</li>
<li>周三一整天，我先无脑按照博客复现了一遍，评测能得25分，甚至40分（不知道是什么原因导致的某个测试点如此“灵活”）</li>
<li>然后开始魔改，中间改碎了两次，甚至用上了<code>git reset --hard</code>强制重开……还把耳机和外套全部搞丢了（幸好最后全部寻回，OS你害人不浅！）。</li>
<li>周四复习了一天人工智能。</li>
<li>周五中午考完，午觉都没睡，直接开干，到晚上基本实现了信号重入和优先级实现的框架，但是参照讨论区大佬搓的测试样例，顺序还是不对。不过已经是一些小细节上的问题了！周五晚上前脑子里想的是：看到胜利的曙光了，明天一定可以结束战斗，然后周日周一再复习复习数据库。</li>
<li>事实证明的确如此，周六7点45到达图书馆开干，12点左右终于通过了上文提到的样例，但一提交竟然只有15分，竟然搞了个编译错误。事已至此，先吃饭吧！</li>
<li>编译错误显然不会是大问题，吃完饭回来我在本地开启编译优化跑了一遍，发现了<code>debug</code>时没有注释掉的<code>printk</code>，好家伙。再一提交，55分，且是16/18和5/6。</li>
<li>逛了逛讨论区，也有和我一样差几个点通过的，但没有什么有价值的解决方案，我检查了几个信号的默认处理方式，发现我对<code>SIGKILL</code>的默认处理是在内核就完成的，那我想干脆跟其他几个统一吧，而且助教在讨论区说过要统一用<code>exit</code>来结束进程，改了一下，提交——100分拿下，此时是周六下午2点多。写写实验报告，美美去和中法和马协的兄弟们拍毕业照。</li>
<li>感谢张杨学姐的博客，对我帮助极大。所以在学习搭建个人博客时，我第一篇上传的就是挑战性任务的报告，希望也能帮助到后来的学弟学妹。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>BUAA-OS</tag>
      </tags>
  </entry>
</search>
